<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Five Mini-Games + Daily Bible Verse</title>
<style>
:root{
  --bg1:#4facfe; --bg2:#00f2fe;
  --card: rgba(255,255,255,0.16);
  --text:#0f172a; --cardText:#ffffff;
  --accent:#ffeb3b; --shadow:0 10px 30px rgba(0,0,0,0.25);
}
.dark{
  --bg1:#0f172a; --bg2:#1e293b;
  --card: rgba(255,255,255,0.08);
  --text:#e5e7eb; --cardText:#e5e7eb; --accent:#ffd54f;
}
*{box-sizing:border-box}
html,body{height:100%; overscroll-behavior:none;}
body{ margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; color:var(--text); overflow-x:hidden; }
.bg-animated{ position:fixed; inset:0; z-index:-3; background: linear-gradient(135deg, var(--bg1), var(--bg2)); background-size: 200% 200%; animation: grad 18s ease-in-out infinite; }
@keyframes grad{ 0%{background-position:0% 0%} 50%{background-position:100% 100%} 100%{background-position:0% 0%} }

header{ text-align:center; padding:26px 16px 10px; }
h1{ margin:0 0 8px; font-weight:900; font-size: clamp(26px, 4vw, 42px); text-shadow: 0 6px 18px rgba(0,0,0,.25); color:#fff }
.topbar{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px; }
button, .tab{
  border:none; color:var(--cardText); background: rgba(255,255,255,0.22);
  padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer;
  backdrop-filter:saturate(160%) blur(4px); box-shadow: var(--shadow);
  transition: transform .12s ease, background .2s ease; text-decoration:none
}
.dark button, .dark .tab{ background: rgba(255,255,255,0.14); }
button:hover, .tab:hover{ transform: translateY(-1px) scale(1.02); background: rgba(255,255,255,0.30); }

.container{ display:grid; grid-template-columns: 1fr; gap:18px; padding: 16px; max-width:1120px; margin:0 auto 40px; }
.card{
  position:relative; width:100%;
  padding:18px; border-radius:18px; background: var(--card);
  box-shadow: var(--shadow); overflow:hidden; backdrop-filter:saturate(160%) blur(8px);
}
.card h2{ margin:0 0 10px; color:var(--cardText) }

footer{ text-align:center; opacity:.85; margin:10px 0 16px; font-size:1rem; font-weight:700; color:#fff }

/* Tabs + game area */
.tabs{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-bottom:8px; }
.tab{ font-weight:900; }
.tab.active{ outline:3px solid rgba(255,255,255,0.6) }

#gameArea{ width:min(920px, 96vw); margin:0 auto; background:var(--card); border-radius:18px; box-shadow:var(--shadow); padding:12px; color:var(--cardText); }
.gameWrap{ display:none; }
.gameWrap.active{ display:block; }
.gameHeader{ display:flex; flex-wrap:wrap; gap:8px; justify-content:space-between; align-items:center; margin:4px 6px 10px; }
.heroCanvas,.smallCanvas{ width:100%; height:520px; background: rgba(0,0,0,0.1); border-radius:14px; display:block; touch-action:none; }
.controlsRow{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

.votdTop{ margin-top:10px; }
.verseRef{ font-weight:900; margin-top:6px; text-align:center }
.verseText{ font-size:1.2rem; line-height:1.5; text-align:center }
.apiNote{ font-size:.9rem; opacity:.8; text-align:center }

.noScroll{ overflow:hidden; }

/* Tic-Tac-Toe cells */
.cell{
  width:120px;height:120px;font-size:46px;border:none;border-radius:16px;
  background:rgba(255,255,255,0.25);color:#111;font-weight:900;box-shadow:var(--shadow);
}
.dark .cell{ color:#fff; }
.badge{ background:#7c3aed; color:#fff; padding:4px 10px; border-radius:999px; font-weight:900 }
</style>
</head>
<body>
<div class="bg-animated"></div>

<header>
  <h1>üéÆ Five Mini-Games + üìñ Daily Bible Verse</h1>
  <div class="topbar"><button id="themeBtn">üåì Theme</button></div>
</header>

<section class="votdTop">
  <article class="card" style="max-width:min(820px,96vw);margin:10px auto;">
    <h2>üìñ Verse of the Day</h2>
    <div id="verse" class="verseText">Loading verse‚Ä¶</div>
    <div id="verseRef" class="verseRef"></div>
    <p class="apiNote" id="apiNote"></p>
  </article>
</section>

<div class="container">
  <section id="gameArea">
    <div class="tabs" id="tabs"></div>

    <!-- 1) Shape Catch -->
    <div class="gameWrap active" data-game="catch">
      <div class="gameHeader">
        <div class="controlsRow">
          <h3>üéØ Shape Catch ‚Äî 30s</h3>
          <button id="catchStart">Start</button>
          <span>Score: <strong id="catchScore">0</strong></span>
          <span>Time: <strong id="catchTime">30</strong>s</span>
          <span>Best: <strong id="catchBest">0</strong></span>
          <span class="badge" id="catchBadge" style="display:none">√ó2 MODE</span>
        </div>
      </div>
      <canvas id="catchCanvas" class="heroCanvas"></canvas>
      <p style="text-align:center; margin:8px 0 0">Move with ‚Üê/‚Üí or drag with mouse/touch.</p>
    </div>

    <!-- 2) Snake -->
    <div class="gameWrap" data-game="snake">
      <div class="gameHeader">
        <div class="controlsRow">
          <h3>üêç Snake</h3>
          <button id="snakeStart">Start</button>
          <span>Score: <strong id="snakeScore">0</strong></span>
        </div>
      </div>
      <canvas id="snakeCanvas" class="smallCanvas"></canvas>
      <p style="text-align:center; margin:8px 0 0">Use arrows or swipe to steer.</p>
    </div>

    <!-- 3) Flappy Dot -->
    <div class="gameWrap" data-game="flap">
      <div class="gameHeader">
        <div class="controlsRow">
          <h3>üü£ Flappy Dot</h3>
          <button id="flapStart">Start</button>
          <span>Score: <strong id="flapScore">0</strong></span>
        </div>
      </div>
      <canvas id="flapCanvas" class="smallCanvas"></canvas>
      <p style="text-align:center; margin:8px 0 0">Tap/Click or press Space.</p>
    </div>

    <!-- 4) Breakout (reworked) -->
    <div class="gameWrap" data-game="breakout">
      <div class="gameHeader">
        <div class="controlsRow">
          <h3>üß± Breakout</h3>
          <button id="brkStart">Start</button>
          <span>Level: <strong id="brkLevel">1</strong></span>
          <span>Score: <strong id="brkScore">0</strong></span>
          <span>Lives: <strong id="brkLives">3</strong></span>
        </div>
      </div>
      <canvas id="brkCanvas" class="smallCanvas"></canvas>
      <p style="text-align:center; margin:8px 0 0">Move with ‚Üê/‚Üí or drag with mouse/touch.</p>
    </div>

    <!-- 5) Tic-Tac-Toe -->
    <div class="gameWrap" data-game="ttt">
      <div class="gameHeader">
        <div class="controlsRow">
          <h3>‚≠ï Tic-Tac-Toe (AI)</h3>
          <button id="tttReset">Reset</button>
          <span id="tttMsg">Your turn (X)</span>
        </div>
      </div>
      <div id="tttGrid" style="display:grid;grid-template-columns:repeat(3,120px);gap:8px;justify-content:center; margin:10px auto"></div>
    </div>

  </section>
</div>

<footer>Have fun & be encouraged ‚ú®</footer>

<script>
/* ===== Helpers & Theme ===== */
const qs=(s,p=document)=>p.querySelector(s); const qsa=(s,p=document)=>[...p.querySelectorAll(s)];
qs('#themeBtn').onclick=()=>document.body.classList.toggle('dark');

/* Lock scrolling while a game is running */
let playing=false;
function lockScroll(on){ document.body.classList.toggle('noScroll', !!on); }
function preventKeys(e){ if(!playing) return; const k=e.key||e.code; if(k===' '||k==='Space'||k==='Spacebar'||(k&&k.startsWith('Arrow'))) e.preventDefault(); }
window.addEventListener('keydown', preventKeys, {passive:false});
document.addEventListener('touchmove', e=>{ if(playing) e.preventDefault(); }, {passive:false});

/* ===== Tabs ===== */
const games=[
  { key:'catch', label:'üéØ Shape Catch' },
  { key:'snake', label:'üêç Snake' },
  { key:'flap',  label:'üü£ Flappy Dot' },
  { key:'breakout',label:'üß± Breakout' },
  { key:'ttt',   label:'‚≠ï Tic-Tac-Toe' },
];
const tabsEl=qs('#tabs'); let current='catch';
function renderTabs(){ tabsEl.innerHTML=''; games.forEach(g=>{ const b=document.createElement('button'); b.className='tab'+(g.key===current?' active':''); b.textContent=g.label; b.onclick=()=>activate(g.key); tabsEl.appendChild(b); }); }
function activate(key){ current=key; renderTabs(); qsa('.gameWrap').forEach(w=>w.classList.toggle('active', w.dataset.game===key)); GAMES[key]?.onShow?.(); }
renderTabs();

/* ===== Verse of the Day (with fallbacks) ===== */
const verseEl=qs('#verse'), refEl=qs('#verseRef'), apiNote=qs('#apiNote');
const FALLBACKS=[
  {ref:'Philippians 4:13', text:'I can do all things through Christ who strengthens me.'},
  {ref:'Luke 1:37', text:'For with God nothing will be impossible.'},
  {ref:'Psalm 46:1', text:'God is our refuge and strength, a very present help in trouble.'},
  {ref:'Proverbs 3:5‚Äì6', text:'Trust in the LORD with all your heart; in all your ways acknowledge him, and he will make straight your paths.'},
  {ref:'Isaiah 41:10', text:'Fear not, for I am with you; I will strengthen you, I will help you.'},
];
function dayIndex(){ return Math.floor(Date.now()/86400000); }
async function fetchVerse(){
  const key='votd:'+dayIndex(); const cached=localStorage.getItem(key);
  if(cached){ try{ const d=JSON.parse(cached); showVerse(d.text,d.ref,'(cached)'); return; }catch{} }
  try{
    const r=await fetch('https://labs.bible.org/api/?passage=votd&formatting=plain');
    if(r.ok){ const t=await r.text(); if(t){ showVerse(t.trim(),'VOTD (labs.bible.org)','(live)'); localStorage.setItem(key, JSON.stringify({text:t.trim(), ref:'VOTD'})); return; } }
  }catch{}
  try{
    const refs=['john 3:16','psalm 23:1','philippians 4:6','matthew 6:34','isaiah 40:31','romans 12:12','psalm 91:1'];
    const ref=encodeURIComponent(refs[dayIndex()%refs.length]);
    const r=await fetch('https://bible-api.com/'+ref);
    if(r.ok){ const j=await r.json(); if(j?.text){ showVerse(j.text.trim(), j.reference||'Bible', '(live)'); localStorage.setItem(key, JSON.stringify({text:j.text.trim(), ref:j.reference||'Bible'})); return; } }
  }catch{}
  const f=FALLBACKS[dayIndex()%FALLBACKS.length]; showVerse(f.text, f.ref, '(offline)');
}
function showVerse(text, ref, note){ verseEl.textContent='‚Äú'+text.replace(/^\"|\"$/g,'')+'‚Äù'; refEl.textContent=ref?('‚Äî '+ref):''; apiNote.textContent=note||''; }
fetchVerse();

/* ===== Games ===== */
const GAMES={};

/* --- 1) Shape Catch (unchanged) --- */
GAMES.catch=(function(){
  const canvas=qs('#catchCanvas'); const scoreEl=qs('#catchScore'); const timeEl=qs('#catchTime'); const bestEl=qs('#catchBest'); const badge=qs('#catchBadge');
  let ctx,w,h,rafId,running=false,tLeft=30,score=0,best=+localStorage.getItem('catchBest')||0; bestEl.textContent=best;
  let catcher,drops=[],lastSpawn=0,flashUntil=0,doubleUntil=0; let keys={};
  const COLORS=["#22d3ee","#60a5fa","#f472b6","#34d399","#fbbf24","#f87171","#a78bfa"];
  function isDouble(){ return performance.now()<doubleUntil; }
  function resize(){ const DPR=window.devicePixelRatio||1; w=canvas.clientWidth; h=canvas.clientHeight; canvas.width=w*DPR; canvas.height=h*DPR; ctx=canvas.getContext('2d'); ctx.setTransform(DPR,0,0,DPR,0,0); catcher={x:w/2,y:h-26,w:Math.max(90,w*0.2),h:16}; }
  function start(){ running=true; playing=true; lockScroll(true); tLeft=30; score=0; scoreEl.textContent=score; timeEl.textContent=tLeft; drops=[]; lastSpawn=performance.now(); doubleUntil=0; badge.style.display='none'; loop(performance.now()); tick(); }
  function spawn(){ const dm=isDouble(); const r=Math.random()*100; let kind,value,color;
    if((!dm&&r<10)||(dm&&r<15)){kind='double';value=2;color='#a855f7';}
    else if((!dm&&r<30)||(dm&&r<50)){kind='bomb';value=-3;color='#111';}
    else if(r<95){kind='good';value=1;color=COLORS[Math|Math.random()*COLORS.length];}
    else {kind='rare';value=3;color='#ffd166';}
    let size,vy;
    if(kind==='double'){size=10+Math.random()*5; vy=3.6+Math.random()*2.2;}
    else if(kind==='bomb'){size=16+Math.random()*10; vy=2.4+Math.random()*2.6;}
    else if(kind==='rare'){size=16+Math.random()*10; vy=2.4+Math.random()*2.4;}
    else {size=14+Math.random()*8; vy=2.2+Math.random()*2.2;}
    if(dm) vy*=1.15; drops.push({kind,value,color,x:Math.random()*w,y:-30,vy,size});
  }
  function roundRect(x,y,ww,hh,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+ww,y,x+ww,y+hh,r); ctx.arcTo(x+ww,y+hh,x,y+hh,r); ctx.arcTo(x,y+hh,x,y,r); ctx.arcTo(x,y,x+ww,y,r); ctx.closePath(); }
  function drawItem(d){
    ctx.save(); ctx.translate(d.x,d.y);
    if(d.kind==='bomb'){
      ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(0,0,d.size*0.9,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#fffb'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(d.size*0.4,-d.size*0.9);
      ctx.bezierCurveTo(d.size*0.6,-d.size*1.4,d.size*0.9,-d.size*1.3,d.size*1.1,-d.size*1.0); ctx.stroke();
      ctx.fillStyle='#ff4d4d'; ctx.beginPath(); ctx.arc(d.size*1.15,-d.size*1.05,3.2,0,Math.PI*2); ctx.fill();
    } else if(d.kind==='rare'){
      ctx.fillStyle=d.color; const R=d.size,r=R*0.45; ctx.beginPath();
      for(let i=0;i<10;i++){ const a=i*Math.PI/5,rad=i%2===0?R:r; ctx.lineTo(Math.cos(a)*rad,Math.sin(a)*rad); }
      ctx.closePath(); ctx.shadowColor='#0006'; ctx.shadowBlur=10; ctx.fill();
    } else if(d.kind==='double'){
      ctx.fillStyle=d.color; const s=d.size,rr=s*0.35; roundRect(-s,-s,s*2,s*2,rr); ctx.fill();
      ctx.fillStyle='#fff'; ctx.font=`${Math.max(10,Math.round(s*1.3))}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('√ó2',0,0);
    } else {
      ctx.fillStyle=d.color; const s=d.size,rr=s*0.35; roundRect(-s,-s,s*2,s*2,rr); ctx.fill();
      ctx.fillStyle='#fff'; ctx.font=`${Math.round(s*1.5)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('M',0,0);
    }
    ctx.restore();
  }
  function drawCatcher(){ ctx.save(); ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.fillRect(catcher.x-catcher.w/2, catcher.y-catcher.h/2, catcher.w, catcher.h); ctx.restore(); }
  function loop(now){
    if(!running) return; requestAnimationFrame(loop);
    const dm=isDouble(); const interval=dm?200:260; if(now-lastSpawn>interval+Math.random()*220){ spawn(); lastSpawn=now; }
    const speed=7+(dm?0.5:0); if(keys['ArrowLeft']) catcher.x-=speed; if(keys['ArrowRight']) catcher.x+=speed;
    catcher.x=Math.max(catcher.w/2,Math.min(w-catcher.w/2,catcher.x));
    ctx.clearRect(0,0,w,h); drawCatcher();
    for(let i=drops.length-1;i>=0;i--){
      const d=drops[i]; d.y+=d.vy; drawItem(d);
      const withinX=Math.abs(d.x-catcher.x)<(catcher.w/2);
      const withinY=Math.abs(d.y-catcher.y)<(catcher.h+Math.max(10,d.size*0.6));
      if(withinX&&withinY){
        drops.splice(i,1);
        if(d.kind==='double'){ score+=2; doubleUntil=performance.now()+7000; badge.style.display='inline-block'; try{navigator.vibrate&&navigator.vibrate([50,40,80]);}catch{} }
        else { const mult=isDouble()?2:1; score+=d.value*mult; if(d.value<0){ try{navigator.vibrate&&navigator.vibrate(120);}catch{} } }
        if(score<0) score=0; scoreEl.textContent=score;
      } else if(d.y>h+40) drops.splice(i,1);
    }
    if(!(performance.now()<doubleUntil)) badge.style.display='none';
  }
  function tick(){ if(!running) return; setTimeout(()=>{ tLeft--; timeEl.textContent=tLeft; if(tLeft<=0){ running=false; playing=false; lockScroll(false); if(score>best){ best=score; localStorage.setItem('catchBest',best);} bestEl.textContent=best; } else tick(); },1000); }
  function onShow(){ resize(); }
  window.addEventListener('resize', ()=>{ if(current==='catch') resize();});
  window.addEventListener('keydown', e=>{ if(current!=='catch') return; if(e.key==='ArrowLeft'||e.key==='ArrowRight'){ e.preventDefault(); keys[e.key]=true; }});
  window.addEventListener('keyup',   e=>{ if(current!=='catch') return; if(e.key==='ArrowLeft'||e.key==='ArrowRight'){ keys[e.key]=false; }});
  canvas.addEventListener('mousemove', e=>{ if(current!=='catch') return; const r=canvas.getBoundingClientRect(); const x=Math.max(0,Math.min(w,e.clientX-r.left)); catcher&&(catcher.x=x);});
  canvas.addEventListener('touchstart', e=>{ if(current!=='catch') return; e.preventDefault(); const t=e.touches[0]; if(!t) return; const r=canvas.getBoundingClientRect(); const x=Math.max(0,Math.min(w,t.clientX-r.left)); catcher&&(catcher.x=x);},{passive:false});
  canvas.addEventListener('touchmove',  e=>{ if(current!=='catch') return; e.preventDefault(); const t=e.touches[0]; if(!t) return; const r=canvas.getBoundingClientRect(); const x=Math.max(0,Math.min(w,t.clientX-r.left)); catcher&&(catcher.x=x);},{passive:false});
  qs('#catchStart').onclick=start;
  return { onShow };
})();

/* --- 2) Snake --- */
GAMES.snake=(function(){
  const canvas=qs('#snakeCanvas'); const scoreEl=qs('#snakeScore');
  let ctx,w,h,grid=20,dir={x:1,y:0},snake,food,alive=false,touchStart=null;
  function resize(){ const DPR=window.devicePixelRatio||1; w=canvas.clientWidth; h=canvas.clientHeight; canvas.width=w*DPR; canvas.height=h*DPR; ctx=canvas.getContext('2d'); ctx.setTransform(DPR,0,0,DPR,0,0); }
  function reset(){ snake=[{x:5,y:5}]; dir={x:1,y:0}; spawnFood(); scoreEl.textContent='0'; alive=true; playing=true; lockScroll(true); step(); }
  function spawnFood(){ food={ x: Math.floor(Math.random()*(w/grid-2))+1, y: Math.floor(Math.random()*(h/grid-2))+1 } }
  function step(){ if(!alive) return; setTimeout(step, 90);
    const head={x:snake[0].x+dir.x, y:snake[0].y+dir.y};
    if(head.x<0||head.y<0||head.x>=(w/grid)||head.y>=(h/grid)|| snake.some(s=>s.x===head.x&&s.y===head.y)){ alive=false; playing=false; lockScroll(false); return; }
    snake.unshift(head);
    if(head.x===food.x && head.y===food.y){ scoreEl.textContent=String(+scoreEl.textContent+1); spawnFood(); } else snake.pop();
    draw();
  }
  function draw(){ ctx.clearRect(0,0,w,h); ctx.fillStyle='rgba(0,0,0,0.35)'; snake.forEach(s=>ctx.fillRect(s.x*grid, s.y*grid, grid-2, grid-2)); ctx.fillStyle='#10b981'; ctx.fillRect(food.x*grid, food.y*grid, grid-2, grid-2); }
  function onShow(){ resize(); draw(); }
  window.addEventListener('resize', ()=>{ if(current==='snake') { resize(); draw(); }});
  qs('#snakeStart').onclick=reset;
  window.addEventListener('keydown', e=>{
    if(current!=='snake') return;
    const k=e.key;
    if(k==='ArrowUp'&&dir.y!==1) dir={x:0,y:-1};
    else if(k==='ArrowDown'&&dir.y!==-1) dir={x:0,y:1};
    else if(k==='ArrowLeft'&&dir.x!==1) dir={x:-1,y:0};
    else if(k==='ArrowRight'&&dir.x!==-1) dir={x:1,y:0};
  });
  canvas.addEventListener('touchstart', e=>{ if(current!=='snake') return; const t=e.touches[0]; if(!t) return; touchStart={x:t.clientX,y:t.clientY}; }, {passive:true});
  canvas.addEventListener('touchmove',  e=>{ if(current!=='snake'||!touchStart) return; e.preventDefault(); const t=e.touches[0]; if(!t) return;
    const dx=t.clientX-touchStart.x, dy=t.clientY-touchStart.y; const ax=Math.abs(dx), ay=Math.abs(dy);
    if(Math.max(ax,ay)>22){ if(ax>ay){ if(dx>0&&dir.x!==-1) dir={x:1,y:0}; else if(dx<0&&dir.x!==1) dir={x:-1,y:0}; } else { if(dy>0&&dir.y!==-1) dir={x:0,y:1}; else if(dy<0&&dir.y!==1) dir={x:0,y:-1}; } touchStart={x:t.clientX,y:t.clientY}; }
  }, {passive:false});
  return { onShow };
})();

/* --- 3) Flappy Dot --- */
GAMES.flap=(function(){
  const canvas=qs('#flapCanvas'); const scoreEl=qs('#flapScore');
  let ctx,w,h; let y,vy,gapX,pipes=[],score,alive=false; const G=0.45, JUMP=-7.2;
  function resize(){ const DPR=window.devicePixelRatio||1; w=canvas.clientWidth; h=canvas.clientHeight; canvas.width=w*DPR; canvas.height=h*DPR; ctx=canvas.getContext('2d'); ctx.setTransform(DPR,0,0,DPR,0,0); if(!alive) draw(); }
  function reset(){ y=h/2; vy=0; pipes=[]; score=0; scoreEl.textContent='0'; gapX=0; alive=true; playing=true; lockScroll(true); step(); }
  function addPipe(){ const gap=140; const top=Math.random()*(h-gap-80)+40; pipes.push({ x:w+20, top:top, bottom:top+gap }); }
  function step(){ if(!alive) return; requestAnimationFrame(step); ctx.clearRect(0,0,w,h);
    vy+=G; y+=vy; if(y>h-10||y<10){ alive=false; playing=false; lockScroll(false); return; }
    if(gapX<=0){ addPipe(); gapX=180; } gapX--; pipes.forEach(p=>p.x-=3.2); pipes=pipes.filter(p=>p.x>-60);
    ctx.fillStyle='rgba(0,0,0,0.35)'; pipes.forEach(p=>{ ctx.fillRect(p.x,0,50,p.top); ctx.fillRect(p.x,p.bottom,50,h-p.bottom); });
    pipes.forEach(p=>{ if(p.x+50<y&&!p.counted){ p.counted=true; score++; scoreEl.textContent=String(score);} const withinX=(p.x<100 && p.x+50>60); if(withinX && (y-10<p.top || y+10>p.bottom)) { alive=false; playing=false; lockScroll(false);} });
    ctx.beginPath(); ctx.arc(80,y,10,0,Math.PI*2); ctx.fillStyle='#8b5cf6'; ctx.fill();
  }
  function flap(){ if(current!=='flap') return; vy=JUMP; }
  function onShow(){ resize(); }
  window.addEventListener('resize', ()=>{ if(current==='flap') resize(); });
  qs('#flapStart').onclick=reset;
  window.addEventListener('keydown', e=>{ if(current==='flap' && (e.code==='Space'||e.key===' ')){ e.preventDefault(); flap(); }});
  canvas.addEventListener('mousedown', flap);
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); flap(); }, {passive:false});
  return { onShow };
})();

/* --- 4) Breakout (robust physics + levels + splits) --- */
GAMES.breakout=(function(){
  const canvas=qs('#brkCanvas'); const scoreEl=qs('#brkScore'); const livesEl=qs('#brkLives'); const levelEl=qs('#brkLevel');
  let ctx,w,h,ball,paddle,bricks,cols,rows,brickW,brickH,score,lives,rafId,keys={},running=false,level=1,speedMul=1;

  function resize(){ const DPR=window.devicePixelRatio||1; w=canvas.clientWidth; h=canvas.clientHeight; canvas.width=w*DPR; canvas.height=h*DPR; ctx=canvas.getContext('2d'); ctx.setTransform(DPR,0,0,DPR,0,0); if(!running) draw(); }

  function start(){
    level=1; score=0; lives=3; levelEl.textContent=level; scoreEl.textContent='0'; livesEl.textContent='3';
    buildLevel(); running=true; playing=true; lockScroll(true); loop();
  }

  function buildLevel(){
    speedMul = 1 + (level-1)*0.08;
    const basePaddle = Math.max(70, w*0.2 - (level-1)*12);
    paddle={w:basePaddle,h:14,x:w/2,y:h-28,speed:8 + (level-1)*0.2};
    ball={x:w/2,y:h*0.6,r:7,vx:(3.0+0.25*(level-1))* (Math.random()<0.5?-1:1),vy:-(3.2+0.25*(level-1))};

    rows = 4 + Math.min(4, level);          // more rows as level goes up
    cols = 8;                                // fixed columns
    brickH = 22; brickW = (w-60)/cols;

    // Build with splits: every other column is a narrow brick (gap), plus random holes
    bricks = [];
    for(let r=0;r<rows;r++){
      const row=[];
      for(let c=0;c<cols;c++){
        const gapCol = (r%2===1 && c%2===0); // patterned gap column
        const hole = Math.random() < Math.min(0.15+level*0.02, 0.35); // random holes
        if(gapCol || hole){ row.push(null); continue; }
        const bx = 30 + c*brickW, by = 40 + r*(brickH+10);
        row.push({x:bx, y:by, w:brickW-6, h:brickH, hit:false});
      }
      bricks.push(row);
    }
  }

  function draw(){
    ctx.clearRect(0,0,w,h);
    // paddle
    ctx.fillStyle='rgba(0,0,0,0.45)';
    ctx.fillRect(paddle.x-paddle.w/2,paddle.y-paddle.h/2,paddle.w,paddle.h);
    // ball
    ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fillStyle='#8b5cf6'; ctx.fill();
    // bricks
    bricks.forEach((row,ri)=>row.forEach((b,ci)=>{
      if(!b || b.hit) return;
      ctx.fillStyle=`hsl(${(ri*cols+ci)*15%360} 85% 55%)`;
      ctx.fillRect(b.x,b.y,b.w,b.h);
    }));
  }

  // Circle-Rect collision (returns normal {nx,ny} and penetration)
  function circleRectColl(cx,cy,r, rx,ry,rw,rh){
    const nx = Math.max(rx, Math.min(cx, rx+rw));
    const ny = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - nx, dy = cy - ny;
    const dist2 = dx*dx + dy*dy;
    if(dist2 > r*r) return null;
    const dist = Math.max(0.0001, Math.sqrt(dist2));
    return { nx: dx/dist, ny: dy/dist, px: nx, py: ny };
  }

  function step(){
    // input
    if(keys['ArrowLeft']) paddle.x-=paddle.speed;
    if(keys['ArrowRight']) paddle.x+=paddle.speed;
    paddle.x=Math.max(paddle.w/2, Math.min(w-paddle.w/2, paddle.x));

    // move ball
    ball.x += ball.vx * speedMul;
    ball.y += ball.vy * speedMul;

    // walls
    if(ball.x<ball.r){ ball.x=ball.r; ball.vx = Math.abs(ball.vx); }
    if(ball.x>w-ball.r){ ball.x=w-ball.r; ball.vx = -Math.abs(ball.vx); }
    if(ball.y<ball.r){ ball.y=ball.r; ball.vy = Math.abs(ball.vy); }

    // paddle collision (use AABB with circle)
    const pc = circleRectColl(ball.x,ball.y,ball.r, paddle.x-paddle.w/2, paddle.y-paddle.h/2, paddle.w, paddle.h);
    if(pc){
      // reflect by normal
      const vdotn = ball.vx*pc.nx + ball.vy*pc.ny;
      ball.vx -= 2*vdotn*pc.nx;
      ball.vy -= 2*vdotn*pc.ny;
      // add english based on hit position
      const off=(ball.x - paddle.x)/(paddle.w/2);
      ball.vx += off*1.6;
      // ensure upward movement
      if(ball.vy > -2.5) ball.vy = -2.5;
    }

    // brick collisions
    outer:
    for(let r=0;r<bricks.length;r++){
      const row=bricks[r];
      for(let c=0;c<row.length;c++){
        const b=row[c]; if(!b || b.hit) continue;
        const col = circleRectColl(ball.x,ball.y,ball.r, b.x,b.y,b.w,b.h);
        if(col){
          b.hit=true; score++; scoreEl.textContent=String(score);
          // reflect by normal
          const vdotn = ball.vx*col.nx + ball.vy*col.ny;
          ball.vx -= 2*vdotn*col.nx;
          ball.vy -= 2*vdotn*col.ny;
          // slight speedup on hit
          const mag=Math.hypot(ball.vx,ball.vy);
          const target=Math.min(7.5, mag*1.02);
          ball.vx = ball.vx/mag * target;
          ball.vy = ball.vy/mag * target;
          break outer;
        }
      }
    }

    // bottom -> lose life
    if(ball.y>h+30){
      lives--; livesEl.textContent=String(lives);
      if(lives<=0){ running=false; playing=false; lockScroll(false); return; }
      // reset ball/paddle but keep bricks/score/level
      paddle.x = w/2;
      ball = {x:w/2, y:h*0.6, r:7, vx:(3.0+0.25*(level-1))*(Math.random()<0.5?-1:1), vy:-(3.2+0.25*(level-1))};
    }

    // prevent corner trap (when near bottom corners for too long)
    if(ball.y > h-40 && Math.abs(ball.vy) < 0.4){
      ball.vy = -2.2;                       // kick upward
      if(Math.abs(ball.vx) < 1.0) ball.vx += (ball.x < w/2 ? 1.2 : -1.2);
    }

    // next level?
    const remaining = bricks.some(row=>row.some(b=>b && !b.hit));
    if(!remaining){
      level++; levelEl.textContent=level;
      buildLevel();
    }
  }

  function loop(){ if(!running){ draw(); return; } rafId=requestAnimationFrame(loop); step(); draw(); }

  function onShow(){ resize(); draw(); }
  // controls
  window.addEventListener('resize', ()=>{ if(current==='breakout') resize(); });
  qs('#brkStart').onclick=()=>{ running=false; start(); };
  window.addEventListener('keydown', e=>{ if(current!=='breakout') return; if(e.key==='ArrowLeft'||e.key==='ArrowRight'){ e.preventDefault(); keys[e.key]=true; }});
  window.addEventListener('keyup', e=>{ if(current!=='breakout') return; if(e.key==='ArrowLeft'||e.key==='ArrowRight'){ keys[e.key]=false; }});
  function moveTo(x){ const r=canvas.getBoundingClientRect(); paddle && (paddle.x=Math.max(paddle.w/2, Math.min(w-paddle.w/2, x-r.left))); }
  canvas.addEventListener('mousemove', e=>{ if(current!=='breakout') return; moveTo(e.clientX); });
  canvas.addEventListener('touchstart', e=>{ if(current!=='breakout') return; e.preventDefault(); if(e.touches[0]) moveTo(e.touches[0].clientX); }, {passive:false});
  canvas.addEventListener('touchmove',  e=>{ if(current!=='breakout') return; e.preventDefault(); if(e.touches[0]) moveTo(e.touches[0].clientX); }, {passive:false});
  return { onShow };
})();

/* --- 5) Tic-Tac-Toe (minimax) --- */
GAMES.ttt=(function(){
  const grid=qs('#tttGrid'); const msg=qs('#tttMsg'); let board, human='X', ai='O', over=false;
  function reset(){ board=Array(9).fill(''); over=false; render(); msg.textContent='Your turn (X)'; }
  function render(){ grid.innerHTML=''; board.forEach((v,i)=>{ const b=document.createElement('button'); b.className='cell'; b.textContent=v; b.onclick=()=>move(i); grid.appendChild(b); }); }
  function move(i){ if(over||board[i]) return; board[i]=human; render(); if(checkEnd()) return; setTimeout(()=>{ aiMove(); checkEnd(); }, 80); }
  function aiMove(){ let best=-1,bestScore=-Infinity; emptyIdx(board).forEach(i=>{ board[i]=ai; const s=minimax(board,false); board[i]=''; if(s>bestScore){ bestScore=s; best=i; } }); if(best>=0) board[best]=ai; render(); }
  function minimax(b,turnAI){ const win=winner(b); if(win===ai) return 1; if(win===human) return -1; if(emptyIdx(b).length===0) return 0; if(turnAI){ let m=-Infinity; emptyIdx(b).forEach(i=>{ b[i]=ai; m=Math.max(m, minimax(b,false)); b[i]='';}); return m; } else { let m=Infinity; emptyIdx(b).forEach(i=>{ b[i]=human; m=Math.min(m, minimax(b,true)); b[i]='';}); return m; } }
  function emptyIdx(b){ return b.map((v,i)=>v?null:i).filter(v=>v!==null); }
  function winner(b){ const L=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]; for(const [a,c,d] of L){ if(b[a]&&b[a]===b[c]&&b[a]===b[d]) return b[a]; } return null; }
  function checkEnd(){ const w=winner(board); if(w){ msg.textContent=(w===human?'You win! üéâ':'AI wins üòº'); over=true; return true; } if(emptyIdx(board).length===0){ msg.textContent='Draw ü§ù'; over=true; return true; } msg.textContent='Your turn (X)'; return false; }
  qs('#tttReset').onclick=reset; function onShow(){ if(!board) reset(); } return { onShow };
})();

/* Init first game layout */
GAMES[current]?.onShow?.();
</script>
</body>
</html>
